# -*- mode: ruby -*-
# vi: set ft=ruby :

require 'yaml'

Vagrant.require_version '>= 1.8.0'

# Find the Vagrant ID if supplied.
id = nil
ARGV.each do |arg|
  id = arg[/\h{7}/] ? arg : id
end

# Determine the current working directory and vagrantfile.
cwd = nil
vagrantfile = ENV['VAGRANT_VAGRANTFILE'] || 'Vagrantfile'
if id != nil
  require 'json'
  vagrant_home = ENV['VAGRANT_HOME'] || "#{Dir.home}/.vagrant.d"
  JSON.parse(File.read("#{vagrant_home}/data/machine-index/index"))['machines'].each do |hash, data|
    if hash[0..6] == id
      cwd = data['vagrantfile_path']
      vagrantfile = data['vagrantfile_name'] != nil ? data['vagrantfile_name'] : vagrantfile
      break
    end
  end
else
  paths = Dir.pwd.split('/')
  while cwd == nil && !paths.empty?
    dir = paths.join('/')
    current = paths.pop
    if File.exists?("#{dir}/#{vagrantfile}")
      cwd = dir
    end
  end
end

# Ensure project Vagrantfile hasn't been customized.
# @TODO - Add secondary check that parses the Vagrantfile if the MD5 is changed.
md5s = [
  "ef550c44b71ef09513fe24c4b564c8a9",
  "d7016a4bfd74cd7411580491dc3fe376"
]
if cwd != nil && md5s.include?(Digest::MD5.file("#{cwd}/#{vagrantfile}").hexdigest)
  config_dir = ENV['BEET_CONFIG_DIR'] || "#{cwd}/.beetbox"
  project_root = config_dir.gsub('/.beetbox', '')
  project_config = "#{config_dir}/config.yml"
  local_config = "#{config_dir}/local.config.yml"

  # Default vagrant config.
  vconfig = {
    'vagrant_box' => 'beet/box',
    'vagrant_box_version' => '>= 0.2.7',
    'vagrant_ip' => '0.0.0.0',
    'vagrant_memory' => 1024,
    'vagrant_cpus' => 2,
    'beet_home' => '/beetbox',
    'beet_base' => '/var/beetbox',
    'beet_domain' => project_root.split('/').last.gsub(/[\._]/, '-') + ".local",
    'beet_aliases' => [],
    'drush_create_alias' => true
  }

  # Create default config file.
  if !File.exist?(project_config)
    require 'fileutils'
    FileUtils::mkdir_p config_dir
    open(project_config, "w+") << "---\nbeet_domain: #{vconfig['beet_domain']}\n"
  end

  pconfig = YAML::load_file(project_config) || nil
  vconfig = vconfig.merge pconfig if !pconfig.nil?

  # Merge local.config.yml
  if File.exist?(local_config)
    lconfig = YAML::load_file(local_config) || nil
    vconfig = vconfig.merge lconfig if !lconfig.nil?
  end

  # Replace variables in YAML config.
  vconfig.each do |key, value|
    while vconfig[key].is_a?(String) && vconfig[key].match(/{{ .* }}/)
      vconfig[key] = vconfig[key].gsub(/{{ (.*?) }}/) { |match| match = vconfig[$1] }
    end
  end

  hostname = vconfig['beet_domain']

  Vagrant.configure("2") do |config|

    # Hosts file plugins.
    if Vagrant.has_plugin?('vagrant-hostsupdater')
      config.hostsupdater.aliases = vconfig['beet_aliases']
    elsif Vagrant.has_plugin?('vagrant-hostmanager')
      config.hostmanager.enabled = true
      config.hostmanager.manage_host = true
      config.hostmanager.aliases = vconfig['beet_aliases']
    end

    # Check for plugins and attempt to install if not (Windows only).
    if Vagrant::Util::Platform.windows?
      %x(vagrant plugin install vagrant-hostsupdater) unless Vagrant.has_plugin?('vagrant-hostsupdater')
      raise 'Your config requires hostsupdater plugin.' unless Vagrant.has_plugin?('vagrant-hostsupdater')
      if vconfig['vagrant_ip'] == "0.0.0.0"
        %x(vagrant plugin install vagrant-auto_network) unless Vagrant.has_plugin?('vagrant-auto_network')
        raise 'Your config requires auto_network plugin.' unless Vagrant.has_plugin?('vagrant-auto_network')
      end
    end

    config.vm.box = vconfig['vagrant_box']
    config.vm.box_version = vconfig['vagrant_box_version']
    config.vm.hostname = hostname
    config.ssh.insert_key = false
    config.ssh.forward_agent = true

    # Network config.
    if vconfig['vagrant_ip'] == "0.0.0.0" && Vagrant.has_plugin?('vagrant-auto_network')
      config.vm.network :private_network, :ip => "0.0.0.0", :auto_network => true
    elsif vconfig['vagrant_ip'] == "0.0.0.0"
      config.vm.network :private_network, :type => "dhcp"
    else
      config.vm.network :private_network, ip: vconfig['vagrant_ip']
    end

    # Vagrant Cachier config.
    if Vagrant.has_plugin?("vagrant-cachier")
      # Configure cached packages to be shared between instances of the same base box.
      # More info on http://fgrehm.viewdocs.io/vagrant-cachier/usage
      config.cache.scope = :box
      config.cache.enable :generic, { "drush" => { cache_dir: "/home/vagrant/.drush/cache" }, }
      config.cache.synced_folder_opts = {
        type: :nfs,
        mount_options: ['rw', 'vers=3', 'tcp', 'nolock']
      }
    end

    # Synced folders.
    config.vm.synced_folder ".", vconfig['beet_base'],
      type: "nfs",
      id: "beetbox"

    if vconfig['beet_debug']
      config.vm.synced_folder "./provisioning", "#{vconfig['beet_home']}/provisioning",
        type: "nfs",
        id: "debug"
      debug_mode = "BEET_DEBUG=true"
    end

    # Provision box
    beet_sh = "#{vconfig['beet_home']}/provisioning/beetbox.sh"
    remote_sh = "https://raw.githubusercontent.com/beetboxvm/beetbox/master/provisioning/beetbox.sh"
    local_provision = "sudo chmod +x #{beet_sh} && #{debug_mode} #{beet_sh}"
    remote_provision = "sudo apt-get -qq update && curl -fsSL #{remote_sh} | sudo bash"
    config.vm.provision "ansible", type: "shell" do |s|
      s.privileged = false
      s.inline = "if [ -f #{beet_sh} ]; then #{local_provision}; else #{remote_provision}; fi"
    end

    # VirtualBox.
    config.vm.provider :virtualbox do |v|
      v.name = "#{config.vm.hostname}.#{Time.now.to_i}"
      v.memory = vconfig['vagrant_memory']
      v.cpus = vconfig['vagrant_cpus']
      v.linked_clone = true
      v.customize ["modifyvm", :id,
        "--natdnshostresolver1", "on",
        "--ioapic", "on",
        "--vrde", "off"
      ]
    end
  end

  # Create local drush alias.
  if vconfig['drush_create_alias']

    alias_file = vconfig['drush_alias_file'] || "#{Dir.home}/.drush/"+hostname+".aliases.drushrc.php"
    alias_file = "#{project_root}/#{vconfig['drush_alias_file']}" if vconfig['drush_alias_file']

    if ARGV[0] == "destroy"
      File.delete(alias_file) if File.exist?(alias_file)
    else
      require 'erb'
      class DrushAlias
        attr_accessor :hostname, :uri, :key, :root
        def template_binding
          binding
        end
      end

      template = <<ALIAS
  <?php

  $aliases['<%= @hostname %>'] = array(
    'uri' => '<%= @uri %>',
    'remote-host' => '<%= @uri %>',
    'remote-user' => 'vagrant',
    'ssh-options' => '-i <%= @key %> -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no',
    'root' => '<%= @root %>',
  );
ALIAS

      alias_file = File.open(alias_file, "w+")
      da = DrushAlias.new
      da.hostname = vconfig['drush_alias_name'] || hostname
      da.uri = hostname
      da.key = "#{Dir.home}/.vagrant.d/insecure_private_key"
      da.root = vconfig['beet_web'] ||= vconfig['beet_root'] ||= vconfig['beet_base']
      alias_file << ERB.new(template).result(da.template_binding)
      alias_file.close
    end
  end

  # Load local Vagrantfile, if exists.
  include_vagrantfile = "#{cwd}/Vagrantfile.local"
  load include_vagrantfile if File.exist?(include_vagrantfile)
end